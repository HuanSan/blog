(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{431:function(t,_,v){"use strict";v.r(_);var a=v(10),r=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"http-各版本差异"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-各版本差异"}},[t._v("#")]),t._v(" HTTP 各版本差异")]),t._v(" "),_("h2",{attrs:{id:"_1、http-1-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、http-1-0"}},[t._v("#")]),t._v(" 1、http 1.0")]),t._v(" "),_("p",[t._v("HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上,是一种无状态、无连接的应用层协议，几年后被 HTTP1.1 代替并广泛使用")]),t._v(" "),_("h2",{attrs:{id:"_2、http-1-1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、http-1-1"}},[t._v("#")]),t._v(" 2、http 1.1")]),t._v(" "),_("ul",[_("li",[t._v("基于文本解析,把所有请求和响应作为纯文本")]),t._v(" "),_("li",[t._v("加入了缓存处理（强缓存和协商缓存）")]),t._v(" "),_("li",[t._v("拥有长连接，并支持请求管道化（pipelining），")]),t._v(" "),_("li",[t._v("流控制基于 tcp 连接。当连接建立时，两端通过系统默认机制建立缓冲区。并通过 ack 报文来通知对方接收窗口大小，因为 http1.1 依靠传输层来避免流溢出，每个 tcp 连接需要一个独立的流控制机制")])]),t._v(" "),_("h3",{attrs:{id:"_2-1-缓存处理-强缓存和协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-缓存处理-强缓存和协商缓存"}},[t._v("#")]),t._v(" 2.1 缓存处理（强缓存和协商缓存）")]),t._v(" "),_("p",[t._v("浏览器缓存能优化性能，而浏览器缓存分为"),_("strong",[t._v("强缓存")]),t._v("和"),_("strong",[t._v("协商缓存")]),t._v("，都是从客户端读取缓存"),_("strong",[t._v("强缓存")])]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("强缓存")]),t._v("不发送请求，直接读取资源，可以获得返回 200 的状态码")]),t._v(" "),_("li",[t._v("利用 http 头中的 Expires 和 Cache-Control 两个字段来控制，都用来表示资源的缓存时间，Expires 能设置失效时间，而 Cache-Control 能做到更多选项更细致，如果同时设置的话，其优先级高于 Expires")])]),t._v(" "),_("h4",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),_("ul",[_("li",[t._v("通过服务器来确定缓存资源是否可用，通过 request header 判断是否命中请求，命中后返回 304 状态码，并返回新的 request header 通知客户端从缓存里取")]),t._v(" "),_("li",[t._v("普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存")]),t._v(" "),_("li",[t._v("如果时间过期，则向服务器发送 header 带有 If-None-Match 和 If-Modified-Since 的请求，回到 1")])]),t._v(" "),_("h2",{attrs:{id:"_3、http-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、http-2"}},[t._v("#")]),t._v(" 3、http 2")]),t._v(" "),_("ul",[_("li",[t._v("相比于 http1.1，性能大幅度提升")]),t._v(" "),_("li",[t._v("通过一个连接来多路复用")]),t._v(" "),_("li",[t._v("拥有头部压缩")]),t._v(" "),_("li",[t._v("拥有新的二进制格式，使用二进制框架层把所有消息封装成二进制，且仍然保持 http 语法")]),t._v(" "),_("li",[t._v("允许客户端和服务器端实现他们自己的流控制机制，而不是依赖传输层,两端在传输层交换可用的缓冲区大小，来让他们在多路复用流上设置自己的接收窗口")]),t._v(" "),_("li",[t._v("让服务器可以将响应主动“推送”到客户端缓存中")])]),t._v(" "),_("h2",{attrs:{id:"_4、http-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、http-3"}},[t._v("#")]),t._v(" 4、http 3")]),t._v(" "),_("ul",[_("li",[t._v("同样拥有头部压缩，并优化了对乱序发送的支持，也优化了压缩率")]),t._v(" "),_("li",[t._v("通过 udp 建立，提高了连接建立的速度，降低了延迟")]),t._v(" "),_("li",[t._v("tcp 本身是无法解决队头拥塞，quic 则解决了这个问题")]),t._v(" "),_("li",[t._v("Connection ID 使得 http3 支持连接迁移以及 NAT 的重绑定")])]),t._v(" "),_("h3",{attrs:{id:"_4-1-tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-tcp"}},[t._v("#")]),t._v(" 4.1 tcp")]),t._v(" "),_("ul",[_("li",[t._v("不支持流级复用，TCP 会将所有对象序列化在同一个流中，因此，它不知道 TCP 段的对象级分区，无法在同一个流中复用数据包")]),t._v(" "),_("li",[t._v("会产生冗余通信，tco 三次连接握手会有冗余的消息交换序列")]),t._v(" "),_("li",[t._v("可能会间歇性地挂起数据传输，tcp 中有个因为序列顺序处理丢失的问题的缺陷称为行头阻塞")])]),t._v(" "),_("h2",{attrs:{id:"_5、参考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5、参考"}},[t._v("#")]),t._v(" 5、参考")]),t._v(" "),_("p",[t._v("https://zhuanlan.zhihu.com/p/469988032?utm_medium=social&utm_oi=1089297405844787200")])])}),[],!1,null,null,null);_.default=r.exports}}]);