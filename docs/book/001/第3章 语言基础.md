# 第3章 语言基础
任何语言的核心所描述的都是这门语言在最基本的层面上如何工作，涉及语法、操作符、数据类型
以及内置功能，在此基础之上才可以构建复杂的解决方案。

## 3.1 语法
ECMAScript 的语法很大程度上借鉴了 C 语言和其他类 C 语言，如 Java和 Perl。熟悉这些语言的开
发者，应该很容易理解 ECMAScript 宽松的语法。

### 3.1.1 区分大小写
ECMAScript 中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。

### 3.1.2 标识符
所谓**标识符**，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：
- 第一个字符必须是一个字母、下划线（ _ ）或美元符号（ $ ）；
- 剩下的其他字符可以是字母、下划线、美元符号或数字。

标识符中的字母可以是扩展 ASCII（Extended ASCII）中的字母，也可以是 Unicode 的字母字符，
如 À 和 Æ（但不推荐使用）。

按照惯例，ECMAScript 标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写，

>**注意** 关键字、保留字、 true 、 false 和 null 不能作为标识符。

### 3.1.3 注释
ECMAScript 采用 C 语言风格的注释，包括单行注释和块注释。

### 3.1.4 严格模式
ECMAScript 5 增加了严格模式（strict mode）的概念。

严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：`"use strict";`

### 3.1.5 语句
ECMAScript 中的语句以分号结尾。即使语句末尾的分号不是必需的，也应该加上。

## 3.2 关键字与保留字
ECMA-262 描述了一组保留的**关键字**，这些关键字有特殊用途，比如表示控制语句的开始和结束，或者执行特定的操作。按照规定，保留的关键字不能用作标识符或属性名。ECMA-262 第 6 版规定的所有关键字如下：
```
    break      do         in           typeof
    case       else       instanceof   var
    catch      export     new          void
    class      extends    return       while
    const      finally    super        with
    continue   for        switch       yield
    debugger   function   this
    default    if         throw
    delete     import     try
```

始终保留: enum

严格模式下保留:
```
    implements   package      public
    interface    protected    static
    let          private
```

模块代码中保留: await

## 3.3 变量
ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量： var 、 const 和 let 。其中， var 在ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6及更晚的版本中使用。

### 3.3.1  var 关键字
要定义变量，可以使用 var 操作符，后跟变量名（即标识符，如前所述）

1. var 声明作用域
使用 var 操作符定义的变量会成为包含它的函数的局部变量。
```javascript
function test() {
    var message = "hi"; // 局部变量
}
test();
console.log(message); // 出错！
```
在函数内定义变量时省略 var 操作符，可以创建一个全局变量：
```javascript
function test() {
    message = "hi"; //  全局变量
}
test();
console.log(message); // "hi"
```
>在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 ReferenceError 。

如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：
```javascript
var message = "hi",
    found = false,
    age = 29;
```
在严格模式下，不能定义名为 eval 和 arguments 的变量，否则会导致语法错误。

2. var 声明提升
使用 var 时，声明的变量会自动提升到函数作用域顶部
```javascript
function foo() {
    console.log(age);
    var age = 26;
}
foo(); // undefined
```

这就是所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用 var 声明同一个变量也没有问题

### 3.3.2  let 声明
let 声明的范围是块作用域，而 var 声明的范围是函数作用域。let 也不允许同一个块作用域中出现冗余声明。
```javascript
if (true) {
    var name = 'Matt';
    console.log(name); // Matt
}
console.log(name); // Matt

if (true) {
    let age = 26;
    console.log(age); // 26
}
console.log(age); // ReferenceError: age 没有定义

let age;
let age; // SyntaxError；标识符 age 已经声明过了
```

JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错
```javascript
let age = 30;
console.log(age); // 30
if (true) {
    let age = 26;
    console.log(age); // 26
}
```
对声明冗余报错不会因混用 let 和 var 而受影响。
```javascript
var name;
let name; // SyntaxError
let age;
var age; // SyntaxError
```

1. 暂时性死区
let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。
```javascript
// name 会被提升
console.log(name); // undefined
var name = 'Matt';
// age 不会被提升
console.log(age); // ReferenceError：age 没有定义
let age = 26;
```
在解析代码时，JavaScript 引擎也会注意出现在块后面的 let 声明，只不过在此之前不能以任何方式来引用未声明的变量。在 let 声明之前的执行瞬间被称为“**暂时性死区**”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出 ReferenceError 。

2. 全局声明
与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（ var 声
明的变量则会）。必须确保页面不会重复声明同一个变量

3. 条件声明
在使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。

4. for 循环中的 let 声明
在 let 出现之前， for 循环定义的迭代变量会渗透到循环体外部：
```javascript
for (var i = 0; i < 5; ++i) {
    // 循环逻辑
}
console.log(i); // 5

for (let i = 0; i < 5; ++i) {
    // 循环逻辑
}
console.log(i); // ReferenceError: i 没有定义

for (var i = 0; i < 5; ++i) {
    setTimeout(() => console.log(i), 0)
}
// 你可能以为会输出 0、1、2、3、4
// 实际上会输出 5、5、5、5、5

for (let i = 0; i < 5; ++i) {
    setTimeout(() => console.log(i), 0)
}
// 会输出 0、1、2、3、4
```

### 3.3.3  const 声明
const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。

const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。
```javascript
const person = {};
person.name = 'Matt'; // ok

for (const key in {a: 1, b: 2}) {
    console.log(key);
}
// a, b
for (const value of [1,2,3,4,5]) {
    console.log(value);
}
// 1, 2, 3, 4, 5
```
### 3.3.4 声明风格及最佳实践
1. 不使用 var
限制自己只使用 let 和 const有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。
2. const 优先， let 次之
使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。

## 3.4 数据类型
ECMAScript 有 6 种简单数据类型（也称为**原始类型**）： Undefined 、 Null 、 Boolean 、 Number 、String 和 Symbol 。

Symbol （符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object （对象）。 Object 是一种无序名值对的集合。因为在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。

### 3.4.1  typeof 操作符
对一个值使用 typeof 操作符会返回下列字符串之一：
- "undefined" 表示值未定义；
- "boolean" 表示值为布尔值；
- "string" 表示值为字符串；
- "number" 表示值为数值；
- "object" 表示值为对象（而不是函数）或 null ；
- "function" 表示值为函数；
- "symbol" 表示值为符号。

注意 typeof 在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用 typeof null 返回的是 "object" 。这是因为特殊值 null 被认为是一个对空对象的引用。

>严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。

### 3.4.2  Undefined 类型
Undefined 类型只有一个值，就是特殊值 undefined 。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值：
```javascript
let message;
console.log(message == undefined); // true
```

>一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针（ null ）和未初始化变量的区别。

undefined 是一个假值。因此，如果需要，可以用更简洁的方式检测它。
```javascript
let message; // 这个变量被声明了，只是值为 undefined
// age 没有声明

if (message) {
    // 这个块不会执行
}

if (!message) {
    // 这个块会执行
}

if (age) {
    // 这里会报错
}
```

### 3.4.3  Null 类型
Null 类型同样只有一个值，即特殊值 null 。逻辑上讲， null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回 "object" 的原因：
```javascript
let car = null;
console.log(typeof car); // "object"
```

在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。

undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，如下面的例子所示：
`console.log(null == undefined); // true`

null 是一个假值。因此，如果需要，可以用更简洁的方式检测它。
```javascript
let message = null;
let age;

if (message) {
    // 这个块不会执行
}

if (!message) {
    // 这个块会执行
}

if (age) {
    // 这个块不会执行
}

if (!age) {
    // 这个块会执行
}
```

### 3.4.4  Boolean 类型
Boolean （布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值： true 和 false 。

>布尔值字面量 true 和 false 是区分大小写的，因此 True 和 False （及其他大小混写形式）
是有效的标识符，但不是布尔值。

将一个其他类型的值转换为布尔值，可以调用特定的 Boolean() 转型函数：
```javascript
let message = "Hello world!";
let messageAsBoolean = Boolean(message);
```

数据类型|转换为 true 的值|转换为 false 的值
--|:--:|--:
Boolean|true|false
String|非空字符串|""（空字符串）
Number|非零数值（包括无穷值）|0、NaN（参见后面的相关内容）
Object|任意对象|null
Undefined|N/A（不存在）| undefined

### 3.4.5  Number 类型
Number 类型使用 IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。

对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数，如下所示：
```javascript
let octalNum1 = 070; // 八进制的 56
let octalNum2 = 079; // 无效的八进制值，当成 79 处理
let octalNum3 = 08; // 无效的八进制值，当成 8 处理
```
八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。

要创建十六进制字面量，必须让真正的数值前缀 0x （区分大小写），然后是十六进制数字（0~9 以及 A~F）。十六进制数字中的字母大小写均可。
```javascript
let hexNum1 = 0xA; // 十六进制 10
let hexNum2 = 0x1f; // 十六进制 31
```

1. 浮点值
```javascript
let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = .1; // 有效，但不推荐

let floatNum1 = 1.; // 小数点后面没有数字，当成整数 1 处理
let floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理

let floatNum = 3.125e7; // 等于 31250000
```
浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。

2. 值的范围
ECMAScript 可以表示的最小
数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e324；可以表示的最大数值保存在Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity （无穷）值。任何无法表示的负数以 -Infinity （负无穷大）表示，任何无法表示的正数以 Infinity （正无穷大）表示。

要确定一个值是不是有限大（即介于 JavaScript 能表示的
最小值和最大值之间），可以使用 isFinite() 函数
```javascript
let result = Number.MAX_VALUE + Number.MAX_VALUE;
console.log(isFinite(result)); // false
```
>使用 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以获取正、负 Infinity 。
3. NaN
有一个特殊的数值叫 NaN ，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。
```javascript
console.log(0/0); // NaN
console.log(-0/+0); // NaN

console.log(5/0); // Infinity
console.log(5/-0); // -Infinity

console.log(NaN == NaN); // false

console.log(isNaN(NaN)); // true
console.log(isNaN(10)); // false，10 是数值
console.log(isNaN("10")); // false，可以转换为数值 10
console.log(isNaN("blue")); // true，不可以转换为数值
console.log(isNaN(true)); // false，可以转换为数值 1
```
>虽然不常见，但 isNaN() 可以用于测试对象。此时，首先会调用对象的 valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 toString() 方法，并测试其返回值。

4. 数值转换
有 3 个函数可以将非数值转换为数值： Number() 、 parseInt() 和 parseFloat() 。  Number() 是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。

Number() 函数基于如下规则执行转换。
- 布尔值， true 转换为 1， false 转换为 0。
- 数值，直接返回。
- null ，返回 0。
- undefined ，返回 NaN 。
- 字符串，应用以下规则。
   - 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。
因此， Number("1") 返回 1， Number("123") 返回 123， Number("011") 返回 11（忽略前面
的零）。
   - 如果字符串包含有效的浮点值格式如 "1.1" ，则会转换为相应的浮点值（同样，忽略前面的零）。
   - 如果字符串包含有效的十六进制格式如 "0xf" ，则会转换为与该十六进制值对应的十进制整
数值。
   - 如果是空字符串（不包含字符），则返回 0。
   - 如果字符串包含除上述情况之外的其他字符，则返回 NaN 。
- 对象，调用 valueOf() 方法，并按照上述规则转换返回的值。如果转换结果是 NaN ，则调用
toString() 方法，再按照转换字符串的规则转换。

```javascript
let num1 = Number("Hello world!"); // NaN
let num2 = Number(""); // 0
let num3 = Number("000011"); // 11
let num4 = Number(true); // 1

let num1 = parseInt("1234blue"); // 1234
let num2 = parseInt(""); // NaN
let num3 = parseInt("0xA"); // 10，解释为十六进制整数
let num4 = parseInt(22.5); // 22
let num5 = parseInt("70"); // 70，解释为十进制值
let num6 = parseInt("0xf"); // 15，解释为十六进制整数

// 事实上，如果提供了十六进制参数，那么字符串前面的 "0x" 可以省掉：
let num1 = parseInt("AF", 16); // 175
let num2 = parseInt("AF"); // NaN

let num1 = parseInt("10", 2); // 2，按二进制解析
let num2 = parseInt("10", 8); // 8，按八进制解析
let num3 = parseInt("10", 10); // 10，按十进制解析
let num4 = parseInt("10", 16); // 16，按十六进制解析
```

parseFloat() 只解析十进制值，因此不能指定底数。

```javascript
let num1 = parseFloat("1234blue"); // 1234，按整数解析
let num2 = parseFloat("0xA"); // 0
let num3 = parseFloat("22.5"); // 22.5
let num4 = parseFloat("22.34.5"); // 22.34
let num5 = parseFloat("0908.5"); // 908.5
let num6 = parseFloat("3.125e7"); // 31250000
```

### 3.4.6  String 类型
String （字符串）数据类型表示零或多个 16 位 Unicode 字符序列。

1. 字符字面量
字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：

字面量|含义
--|:--:|
\n | 换行
\t | 制表
\b | 退格
\r | 回车
\f | 换页
\\\ | 反斜杠
\\' | 单引号
\\" | 双引号
\\` | 反引号
\xnn | 以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F），例如 \x41 等于 "A"
\unnn | 以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字 0~F），例如 \u03a3 等于希腊字符 "Σ"

2. 字符串的特点
ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改
某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如
下所示：
```javascript
let lang = "Java";
lang = lang + "Script";
```

3. 转换为字符串
toString() 方法可见于数值、布尔值、对象和字符串值。该方法只是简单地返回自身的一个副本。） null 和 undefined 值没有 toString() 方法。

默认情况下， toString() 返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示

如果你不确定一个值是不是 null 或 undefined ，可以使用 String() 转型函数，它始终会返回表示相应类型值的字符串。 String() 函数遵循如下规则。
- 如果值有 toString() 方法，则调用该方法（不传参数）并返回结果。
- 如果值是 null ，返回 "null" 。
- 如果值是 undefined ，返回 "undefined" 。

4. 模板字面量
ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量
保留换行字符，可以跨行定义字符串：
```javascript
let myMultiLineTemplateLiteral = `first line
second line`;
```

5. 字符串插值
模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。
字符串插值通过在 ${} 中使用一个 JavaScript 表达式实现：
```javascript
let interpolatedTemplateLiteral =
`${ value } to the ${ exponent } power is ${ value * value }`;
```

所有插入的值都会使用 toString() 强制转型为字符串，而且任何 JavaScript 表达式都可以用于插
值。嵌套的模板字符串无须转义

6. 模板字面量标签函数
模板字面量也支持定义**标签函数**（tag function），而通过标签函数可以自定义插值行为。
```javascript
let num1 = 6;
let num2 = 7;

function foo (a, b, c, d) {
    console.log(a);
    console.log(b);
    console.log(c);
    console.log(d)
}

foo`num1${num1}+num2${num2}=${num1 + num2}`
```

因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个
数组中：
```javascript
function foo (a, ...b) {
    console.log(a);
    for(const item of b) {
        console.log(item);
    }
}

let a = 6;
let b = 9;
function zipTag(strings, ...expressions) {
return strings[0] +
expressions.map((e, i) => `${e}${strings[i + 1]}`)
.join('');
}
let untaggedResult = `${ a } + ${ b } = ${ a + b }`;
let taggedResult = zipTag`${ a } + ${ b } = ${ a + b }`;
console.log(untaggedResult); // "6 + 9 = 15"
console.log(taggedResult); // "6 + 9 = 15"
```

7. 原始字符串
使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转
换后的字符表示。为此，可以使用默认的 String.raw 标签函数：
```javascript
// Unicode 示例
// \u00A9 是版权符号
console.log(`\u00A9`); // ©
console.log(String.raw`\u00A9`); // \u00A9
```

### 3.4.7  Symbol 类型
Symbol （符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。
符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。

符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。

#### 符号的基本用法
符号需要使用 Symbol() 函数初始化。因为符号本身是原始类型，所以 typeof 操作符对符号返回symbol 。[详细介绍](/technology/Symbol.html)
```javascript
let sym = new Symbol();
console.log(typeof sym); // symbol
```

### 3.4.8  Object 类型
ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称
来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：
```javascript
let o = new Object();
```

如果没有参数，如上面的例子所示，那么完全可以省略括号（不推荐）：
```javascript
let o = new Object; // 合法，但不推荐
```

每个 Object 实例都有如下属性和方法。
- constructor ：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object()函数。
- hasOwnProperty(propertyName) ：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如 o.hasOwnProperty("name") ）或符号。
- isPrototypeOf(object) ：用于判断当前对象是否为另一个对象的原型。（第 8 章将详细介绍原型。）
- propertyIsEnumerable(propertyName) ：用于判断给定的属性是否可以使用（本章稍后讨论的） for-in 语句枚举。与 hasOwnProperty() 一样，属性名必须是字符串。
- toLocaleString() ：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。
- toString() ：返回对象的字符串表示。
- valueOf() ：返回对象对应的字符串、数值或布尔值表示。通常与 toString() 的返回值相同。
因为在 ECMAScript 中 Object 是所有对象的基类，所以任何对象都有这些属性和方法。

>注意 严格来讲，ECMA-262 中对象的行为不一定适合 JavaScript 中的其他对象。比如浏
览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象
不受 ECMA-262 约束，所以它们可能会也可能不会继承 Object 。

## 3.5 操作符
ECMA-262 描述了一组可用于操作数据值的**操作符**，包括数学操作符（如加、减）、位操作符、关
系操作符和相等操作符等。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、
数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf() 和/或 toString() 方
法来取得可以计算的值。

### 3.5.1 一元操作符
只操作一个值的操作符叫**一元操作符**（unary operator）。一元操作符是 ECMAScript中最简单的操作符。

1. 递增/递减操作符

