# HTTP 各版本差异

## 1、http 1.0

HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上,是一种无状态、无连接的应用层协议，几年后被 HTTP1.1 代替并广泛使用

## 2、http 1.1

- 基于文本解析,把所有请求和响应作为纯文本
- 加入了缓存处理（强缓存和协商缓存）
- 拥有长连接，并支持请求管道化（pipelining），
- 流控制基于 tcp 连接。当连接建立时，两端通过系统默认机制建立缓冲区。并通过 ack 报文来通知对方接收窗口大小，因为 http1.1 依靠传输层来避免流溢出，每个 tcp 连接需要一个独立的流控制机制

### 2.1 缓存处理（强缓存和协商缓存）

浏览器缓存能优化性能，而浏览器缓存分为**强缓存**和**协商缓存**，都是从客户端读取缓存**强缓存**

- **强缓存**不发送请求，直接读取资源，可以获得返回 200 的状态码
- 利用 http 头中的 Expires 和 Cache-Control 两个字段来控制，都用来表示资源的缓存时间，Expires 能设置失效时间，而 Cache-Control 能做到更多选项更细致，如果同时设置的话，其优先级高于 Expires

#### 协商缓存

- 通过服务器来确定缓存资源是否可用，通过 request header 判断是否命中请求，命中后返回 304 状态码，并返回新的 request header 通知客户端从缓存里取
- 普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存
- 如果时间过期，则向服务器发送 header 带有 If-None-Match 和 If-Modified-Since 的请求，回到 1

## 3、http 2

- 相比于 http1.1，性能大幅度提升
- 通过一个连接来多路复用
- 拥有头部压缩
- 拥有新的二进制格式，使用二进制框架层把所有消息封装成二进制，且仍然保持 http 语法
- 允许客户端和服务器端实现他们自己的流控制机制，而不是依赖传输层,两端在传输层交换可用的缓冲区大小，来让他们在多路复用流上设置自己的接收窗口
- 让服务器可以将响应主动“推送”到客户端缓存中

## 4、http 3

- 同样拥有头部压缩，并优化了对乱序发送的支持，也优化了压缩率
- 通过 udp 建立，提高了连接建立的速度，降低了延迟
- tcp 本身是无法解决队头拥塞，quic 则解决了这个问题
- Connection ID 使得 http3 支持连接迁移以及 NAT 的重绑定

### 4.1 tcp

- 不支持流级复用，TCP 会将所有对象序列化在同一个流中，因此，它不知道 TCP 段的对象级分区，无法在同一个流中复用数据包
- 会产生冗余通信，tco 三次连接握手会有冗余的消息交换序列
- 可能会间歇性地挂起数据传输，tcp 中有个因为序列顺序处理丢失的问题的缺陷称为行头阻塞

## 5、参考

https://zhuanlan.zhihu.com/p/469988032?utm_medium=social&utm_oi=1089297405844787200
