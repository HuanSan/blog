# vue基础知识

## 1、基础使用

### 1.1 文档型学习

### 1.2 mixin 使用

### 1.3 vue 生命周期

## 2、组件

### 2.1 组件设计

### 2.2 调用组件方式

### 2.3 组件通信

## 3、vue-router

### 3.1 路由方式

#### 3.1.1 hash

#### 3.1.2 history

### 3.2 addRoutes 原理

### 3.3 router-view

### 3.4 router-link

### 3.5 钩子类型

### 3.6 执行流程

## 4、axios

### 4.1 实现&配置

### 4.2 拦截器实现

### 4.3 多平台使用axios原因

### 4.4 配置覆盖（默认配置，全局配置，实例配置）

### 4.5 如何取消请求

## 5、vuex

### 5.1 vuex的理解

### 5.2 actions和mutations的区别

### 5.3 如何设计

### 5.4 页面刷新存储数据

### 5.5 vuex的执行流程

### 5.6 vuex的state和getters是如何映射到各个组件实例中响应更新状态的

### 5.7 vuex中state数据变化时，视图更新原理

### 5.8 modules的数据结构和设计结构

### 5.9 getters的执行过程

### 5.10 mutations的执行流程

### 5.11 actions的执行流程

### 5.12 actions中dispatch执行异步操作流程

## 6、版本学习

### 6.1 vue2.0

### 6.2 vue3.0

## 7、项目优化

### 7.1 项目目录设计

### 7.2 实现方式设计

### 7.3 性能优化

## 8、权限控制

## 9、服务端渲染ssr

## 10、vue-cli

## 11、原理

### 11.1 响应式数据理解（vue2、vue3）

### 11.2 vue如何检测数组变化

### 11.3 vue模板编译原理

### 11.4 生命周期钩子如何实现的

### 11.5 vue mixin使用场景和原理

### 11.6 vue nextTick使用场景和原理

### 11.7 为什么需要使用虚拟Dom

### 11.8 vue中diff算法的原理

### 11.9 vue set的方法实现原理，为什么$set能够进行数据实时更新

### 11.10 directive 的实现

### 11.11 vue中slot时如何实现的

### 11.12 keep-alive的原理

### 11.13 $refs是如何实现的

### 11.14 $attrs是为了解决什么问题出现的，应用场景有哪些？provide/inject不能解决这些问题么？

### 11.15 vue中的data为什么是个函数

### 11.16 v-show和v-if的区别

### 11.17 vue.use是干什么的，原理是什么

### 11.18 函数式组件的优势和原理

### 11.19 v-if和v-for的优先级

### 11.20 组件中的name属性有哪些作用

### 11.21 vue的修饰符

### 11.22 vue使用了哪些设计模式

### 11.23 vue中computed特点

### 11.24 vue的事件绑定原理

### 11.25 watch中deep的实现

### 11.26 v-html会导致什么问题

### 11.27 v-html会导致什么问题

### 11.28 v-model原理以及如何实现自定义v-model

### 11.29 组件渲染及更新过程