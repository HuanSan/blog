(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{361:function(_,t,v){"use strict";v.r(t);var e=v(10),l=Object(e.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"回流与重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回流与重绘"}},[_._v("#")]),_._v(" 回流与重绘")]),_._v(" "),t("p",[_._v("在写回流与重绘之前我们先了解浏览器的渲染")]),_._v(" "),t("h2",{attrs:{id:"_1、浏览器渲染解析流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、浏览器渲染解析流程"}},[_._v("#")]),_._v(" 1、浏览器渲染解析流程")]),_._v(" "),t("p",[_._v("浏览器渲染引擎工作流程都差不多，大致分为5步：")]),_._v(" "),t("p",[t("strong",[_._v("创建DOM树")]),_._v("——"),t("strong",[_._v("创建StyleRules")]),_._v("——"),t("strong",[_._v("创建Render树")]),_._v("——"),t("strong",[_._v("布局Layout")]),_._v("——"),t("strong",[_._v("绘制Painting")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("第一步，用HTML分析器，分析HTML元素，构建一颗DOM树(标记化和树构建)。")])]),_._v(" "),t("li",[t("p",[_._v("第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。")])]),_._v(" "),t("li",[t("p",[_._v("第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。每个DOM节点都有"),t("strong",[_._v("attach方法，接受样式信息")]),_._v("，返回一个render对象(又名renderer)。这些render对象最终会被构建成一颗Render树。")])]),_._v(" "),t("li",[t("p",[_._v("第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。")])]),_._v(" "),t("li",[t("p",[_._v("第五步，Render树和节点显示坐标都有了，就调用每个节点"),t("strong",[_._v("paint方法")]),_._v("，把它们绘制出来。")])])]),_._v(" "),t("p",[_._v("DOM树的构建是文档加载完成开始的？构建DOM数是一个渐进过程，为达到更好用户体验，渲染引擎会尽快将内容显示在屏幕上。它不必等到整个HTML文档解析完毕之后才开始构建render数和布局。")]),_._v(" "),t("p",[_._v("Render树是DOM树和CSSOM树构建完毕才开始构建的吗？这三个过程在实际进行的时候又不是完全独立，而是会有交叉。会造成一边加载，一遍解析，一遍渲染的工作现象。")]),_._v(" "),t("p",[_._v("CSS的解析是从右往左逆向解析的(从DOM树的下－上解析比上－下解析效率高)，"),t("strong",[_._v("嵌套标签越多，解析越慢")]),_._v("。")]),_._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"webkit渲染引擎工作流程",href:"/blog/img/web/1/1.png"}},[t("img",{attrs:{src:_.$withBase("/img/web/1/1.png"),alt:"webkit渲染引擎工作流程"}})])]),_._v(" "),t("p",[_._v("webkit渲染引擎工作流程")]),_._v(" "),t("h2",{attrs:{id:"_2、浏览器的回流与重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、浏览器的回流与重绘"}},[_._v("#")]),_._v(" 2、浏览器的回流与重绘")]),_._v(" "),t("p",[_._v("划重点：回流必将引起重绘，重绘不一定会引起回流。")]),_._v(" "),t("h3",{attrs:{id:"_2-1-回流-reflow"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-回流-reflow"}},[_._v("#")]),_._v(" 2.1 回流 (Reflow)")]),_._v(" "),t("p",[_._v("当Render树中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。")]),_._v(" "),t("p",[_._v("会导致回流的操作：")]),_._v(" "),t("ul",[t("li",[_._v("页面首次渲染")]),_._v(" "),t("li",[_._v("浏览器窗口大小发生改变")]),_._v(" "),t("li",[_._v("元素尺寸或位置发生改变")]),_._v(" "),t("li",[_._v("元素内容变化（文字数量或图片大小等等）")]),_._v(" "),t("li",[_._v("元素字体大小变化")]),_._v(" "),t("li",[_._v("添加或者删除可见的DOM元素")]),_._v(" "),t("li",[_._v("激活CSS伪类（例如：:hover）")]),_._v(" "),t("li",[_._v("查询某些属性或调用某些方法")])]),_._v(" "),t("p",[_._v("一些常用且会导致回流的属性和方法：")]),_._v(" "),t("ul",[t("li",[_._v("clientWidth、clientHeight、clientTop、clientLeft")]),_._v(" "),t("li",[_._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),_._v(" "),t("li",[_._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),_._v(" "),t("li",[_._v("scrollIntoView()、scrollIntoViewIfNeeded()")]),_._v(" "),t("li",[_._v("getComputedStyle()")]),_._v(" "),t("li",[_._v("getBoundingClientRect()")]),_._v(" "),t("li",[_._v("scrollTo()")])]),_._v(" "),t("h3",{attrs:{id:"_2-2-重绘-repaint"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-重绘-repaint"}},[_._v("#")]),_._v(" 2.2 重绘 (Repaint)")]),_._v(" "),t("p",[_._v("当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。")]),_._v(" "),t("h3",{attrs:{id:"_2-3-性能影响"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-性能影响"}},[_._v("#")]),_._v(" 2.3 性能影响")]),_._v(" "),t("p",[t("strong",[_._v("回流比重绘的代价要更高。")])]),_._v(" "),t("p",[_._v("有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。")]),_._v(" "),t("p",[_._v("现代浏览器会对频繁的回流或重绘操作进行优化：")]),_._v(" "),t("p",[_._v("浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。")]),_._v(" "),t("p",[_._v("当你访问以下属性或方法时，浏览器会立刻清空队列：")]),_._v(" "),t("ul",[t("li",[_._v("clientWidth、clientHeight、clientTop、clientLeft")]),_._v(" "),t("li",[_._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),_._v(" "),t("li",[_._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),_._v(" "),t("li",[_._v("width、height")]),_._v(" "),t("li",[_._v("getComputedStyle()")]),_._v(" "),t("li",[_._v("getBoundingClientRect()")])]),_._v(" "),t("p",[_._v("因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。")]),_._v(" "),t("h3",{attrs:{id:"_2-4-如何避免"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-如何避免"}},[_._v("#")]),_._v(" 2.4 如何避免")]),_._v(" "),t("ol",[t("li",[_._v("CSS")])]),_._v(" "),t("ul",[t("li",[_._v("避免使用table布局。")]),_._v(" "),t("li",[_._v("尽可能在DOM树的最末端改变class。")]),_._v(" "),t("li",[_._v("避免设置多层内联样式。")]),_._v(" "),t("li",[_._v("将动画效果应用到position属性为absolute或fixed的元素上。")]),_._v(" "),t("li",[_._v("避免使用CSS表达式（例如：calc()）。")])]),_._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[_._v("JavaScript")])]),_._v(" "),t("ul",[t("li",[_._v("避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。")]),_._v(" "),t("li",[_._v("避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。")]),_._v(" "),t("li",[_._v("也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。")]),_._v(" "),t("li",[_._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")]),_._v(" "),t("li",[_._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。")])])])}),[],!1,null,null,null);t.default=l.exports}}]);